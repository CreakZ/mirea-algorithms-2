#import "../../assets/title_page.typ": *

#import "@preview/codelst:2.0.1": *

#set text(size: 14pt, font: "New Computer Modern")
#set heading(numbering: "1.1.1.")
#set page(margin: 2cm)

#set figure(supplement: [Рисунок])
#set figure.caption(separator: [ -- ])

#show heading: it => align(center, it)

#title_page_me(
  6.1,
  [Быстрый доступ к данным с помощью хеш-таблиц]
)

#outline(
  title: [Оглавление]
)

#set page(numbering: "1")
#set par(justify: true, first-line-indent: 1.25cm)

#pagebreak()

#h(1.25cm) *Цель работы:* представление конкретной реализации АТД $quote.angle.l.double$хеш-таблица$quote.angle.r.double$ с базовыми операциями вставки, удаления и вывода записей, а также методом устранения коллизий хеш-функции, определенным персональным вариантом (в моем случае, вариант №18).

= Выполнение работы 

== Формулировка задачи

_Примечание: ниже приведен дословный текст задания_

Разработайте приложение, которое использует хеш-таблицу (пары «ключ-хеш») для организации прямого доступа к элементам динамического множества полезных данных. Множество реализуйте на массиве, структура элементов (перечень полей) которого приведена в инди-
видуальном варианте (п.3).

Приложение должно содержать класс с базовыми операциями: вставки, удаления, поиска по ключу, вывода. Включите в класс массив полезных данных и хеш-таблицу. Хеш-функцию
подберите самостоятельно, используя правила выбора функции.

Реализуйте расширение размера таблицы и рехеширование, когда это требуется, в соответствии с типом разрешения коллизий.

Предусмотрите автоматическое заполнение таблицы 5-7 записями.

Реализуйте текстовый командный интерфейс пользователя для возможности вызова методов в любой произвольной последовательности, сопроводите вывод достаточными для понимания происходящего сторонним пользователем подсказками.

Проведите полное тестирование программы (все базовые операции, изменение размера и
рехеширование), тест-примеры определите самостоятельно. Результаты тестирования включите
в отчет по выполненной работе.

Оформите отчёт с подробным описанием созданного массива и хеш-таблицы, подходов к
программной реализации базовых операций, описанием текста исходного кода и проведенного
тестирования программы.

== Математическая модель

#h(1.25cm) Хеш-таблица с линейным пробированием состоит из нескольких компонентов. Во-первых, функция хеширования, отображающая каждый ключ $k$, который представляет собой шестизначное число, в индекс массива фиксированной длины $N$. Хеш-функция (назовем ее $h(k)$) вычисляется как остаток от деления ключа на размер таблицы, то есть $h(k)=k mod N$. Такой подход позволяет равномерно распределить ключи по индексам массива, минимизируя вероятность коллизий.

Когда возникает коллизия (то есть когда два разных ключа отображаются в один и тот же индекс), применяется метод линейного пробирования. При линейном пробировании в случае коллизии алгоритм последовательно проверяет следующие ячейки массива до тех пор, пока не найдет свободную. Это можно выразить следующим образом: если начальный индекс для ключа $k$ — это $h(k)$, то при коллизии следующий индекс для проверки будет $(h(k)+i) mod N$, где $i$ — это количество шагов пробирования, которое увеличивается на 1 после каждой неудачной попытки вставки или поиска.

При заполнении таблицы до определенного порога заполняемости происходит увеличение её размера (расширение) и рехеширование существующих элементов в новый массив. Новый размер массива, как правило, берется больше предыдущего и желательно простым числом для лучшего распределения хешей. Все элементы перехешируются с использованием обновленного значения $N$ и добавляются в новые позиции согласно новой хеш-функции, что уменьшает вероятность коллизий.

== Код программы

#{
  set par(justify: false)
  let src = raw(read("src/main.cpp"), lang: "c")
  sourcecode(src)
}

#pagebreak()

== Тестирование

=== Добавление продукта

#h(1.25cm) Добавим в хеш-таблицу запись с ключом `100001` (см. рис. 2).

#figure(
  image(
    "img/add.png",
    width: 60%
  ),
  caption: [Добавление записи в хеш-таблицу]
)

#h(1.25cm) Убедимся, что запись дейсвительно добавилась (см. рис. 3).

#figure(
  image(
    "img/add-result.png",
    width: 60%
  ),
  caption: [Проверка добавления записи]
)

#h(1.25cm) Попробуем добавить в хеш-таблицу запись с уже существующим ключом и убедимся, что это не представляется возможным (см. рис. 4). 

#figure(
  image(
    "img/add-existing.png",
    width: 60%
  ),
  caption: [Попытка добавления существующей записи]
)

#pagebreak()

=== Удаление продукта

#h(1.25cm) Удалим запись по ключу `112233` (см. рис. 5).

#figure(
  image(
    "img/delete.png",
    width: 60%
  ),
  caption: [Удаление записи из хеш-таблицы]
)

#h(1.25cm) Убедимся, что запись дейсвительно удалилась (см. рис. 6).

#figure(
  image(
    "img/delete-result.png",
    width: 60%
  ),
  caption: [Проверка удаления записи]
)

#h(1.25cm) Попробуем удалить из хеш-таблицы запись с несуществующим ключом и убедимся, что это не представляется возможным (см. рис. 7).

#figure(
  image(
    "img/delete-non-existing.png",
    width: 60%
  ),
  caption: [Попытка удаления несуществующей записи]
)

#pagebreak()

=== Поиск продукта

#h(1.25cm) Осуществим поиск в хеш-таблице по ключу `654321` (см. рис. 8).

#figure(
  image(
    "img/find.png",
    width: 60%
  ),
  caption: [Поиск записи в хеш-таблице]
)

#h(1.25cm) Теперь попытаемся осуществить поиск по несуществующему ключу и убедимся, что никаких записей найдено не будет (см. рис. 9).

#figure(
  image(
    "img/find-non-existing.png",
    width: 60%
  ),
  caption: [Поиск по несуществующему ключу]
)

#pagebreak()

=== Вывод всех продуктов

#h(1.25cm) Осуществим вывод всех записей в хеш-таблице (см. рис. 10).

#figure(
  image(
    "img/display.png",
    width: 60%
  ),
  caption: [Вывод всех записей в хеш-таблице]
)

#pagebreak()

= Вывод

#h(1.25cm) В ходе работы была разработана хеш-таблица с использованием открытой адресации и линейного пробирования для разрешения коллизий. Реализованы базовые операции вставки, поиска, удаления, а также расширение таблицы с рехешированием, что обеспечивает динамическое управление размером хранилища. Проведенное тестирование показало корректность работы алгоритма и его способность эффективно обрабатывать случаи коллизий, сохраняя производительность при росте объема данных. 

Cтруктура данных $quote.angle.l.double$хеш-таблица$quote.angle.r.double$ позволяет осуществлять прямой доступ к элементам, что делает её подходящей для приложений, требующих быстрой выборки и модификации информации.
