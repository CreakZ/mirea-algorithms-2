#import "../../assets/alter_title_page.typ": title_page

#import "@preview/codelst:2.0.1": sourcecode

#set page(margin: 2cm)
#set text(size: 14pt, font: "New Computer Modern")
#set heading(numbering: "1.")
#set figure(supplement: [Рисунок])
#set figure.caption(separator: [ -- ])

#show heading: it => align(center)[#it]

#let c = counter("pic")

#let check_pic() = {
  c.step()

  [см. рис. #context c.display()]
}

#title_page(
  5.1, 
  [Структуры и алгоритмы обработки данных], 
  [Битовые операции. Сортировка числового файла с помощью битового массива], 
  [Сорокин А.В.]
)

#outline(
  title: [Содержание]
)

#pagebreak()

#set page(numbering: "1")
#set par(justify: true)

#let my_par(txt) = {
  let indent = 1.25cm

  h(indent)
  
  txt
}

#my_par([*Цель работы: *
освоить приёмы работы с битовым представлением
беззнаковых целых чисел, реализовать эффективный алгоритм внешней
сортировки на основе битового массива.])

= Задание 1

== Формулировка задачи

#my_par([
  В
языке
программирования
С++
предусмотрено
несколько
целочисленных типов данных: `bool` (он же логический), `char` (он же
символьный), `short int` (чаще просто short), `long int` (он же int или long) и `long`
`long int` (или просто `long long`). Числа этих типов занимают в памяти
компьютера по 1, 2, 4 и 8 байт соответственно.
])

#my_par([
  Значения всех этих типов бывают знаковые (`signed`) и беззнаковые
(`unsigned`). В первом случае диапазон допустимых значений каждого из
названных типов включает в себя как положительные, так и отрицательные
числа. Во втором случае – только неотрицательные.
])

#my_par([
  Разница диапазонов является следствием способа хранения целых чисел
в памяти ЭВМ современных архитектур. Конечно, целое число в памяти
хранится как битовая последовательность той длины, которая предусмотрена
тем или иным типом.
])

#my_par([
  В беззнаковом типе все двоичные разряды (биты) отведены под
абсолютное значение (модуль) числа. В числе со знаком под модуль отведены
все двоичные разряды, кроме старшего. Одно из значений старшего бита
интерпретируется как знак «плюс», противоположное – как «минус». Т.к.
разрядов под модуль числа на 1 меньше, то и наибольшее допустимое значение
в типе со знаком вдвое меньше такового в беззнаковом типе. Примечание:
векторный способ организации числовых последовательностей (т.е. массивы
чисел) в памяти компьютера формирует непрерывную последовательность бит
от начального до конечного элемента этого массива.
])

#my_par([
  При работе с битовыми представлениями чисел можно использовать
битовые операции, определённые в языке С++.
])

== Математическая модель подзадания а

#my_par([
  Данный алгоритм реализует побитовую операцию для модификации
определённого бита в двоичном представлении числа. Переменная $x$
инициализируется значением 255, что в двоичной системе соответствует
числу `11111111`. Переменной `mask` присваивается значение 1 (`00000001`),
которое впоследствии сдвигается влево на 4 позиции, преобразуясь в двоичное
число `00010000`. Затем происходит инвертирование маски, в результате чего
она принимает значение `11101111`, что эквивалентно сбросу пятого бита.
Далее выполняется побитовая операция И между переменной `x` и данной
маской, что приводит к обнулению пятого бита в числе `x`. Итоговое значение
переменной `x` составляет 239, что соответствует результату операции и
выводится на экран.
])

== Код программы

#my_par([Реализуем код этой программы на языке С++. Результат представлен на
рисунке ниже (#check_pic())])

#let task_1_1 = raw(read("../src/task_1_1.cpp"))

#figure(
  sourcecode(
    lang: "cpp",
    task_1_1
  ),
  caption: [Реализация алгоритма]
)

#my_par([
  В результате выполнения программа выведет следующее (#check_pic()):
])

#figure(
  sourcecode(
    ```sh
    239
    ```
  ),
  caption: [Вывод программы]
)

== Математическая модель подзадания б

#my_par([
  Этот код выполняет установку 7-го бита числа в единицу. Сначала
переменной `x` присваивается значение 0, что в двоичном представлении
равно `00000000`. Затем переменной `mask` присваивается значение 1,
представленное как `00000001`. Операцией сдвига влево на 6 позиций маска
преобразуется в значение `01000000`, что соответствует установке 7-го бита в
единицу. В дальнейшем выполняется побитовая операция ИЛИ между
переменной `x` и маской, что устанавливает 7-й бит переменной `x` в единицу.
Результат операции — значение 64 (`01000000`), которое выводится на экран.
])

== Код программы

#my_par([Реализуем код этой программы на языке С++. Результат представлен на
рисунке ниже (#check_pic())
])

#let task_1_2 = raw(read("../src/task_1_2.cpp"))

#figure(
  sourcecode(
    lang: "cpp",
    task_1_2
  ),
  caption: [Реализация алгоритма]
)

#my_par([
  В результате выполнения программа выведет следующее (#check_pic()):
])

#figure(
  sourcecode(
    ```sh
    64
    ```
  ),
  caption: [Вывод программы]
)

== Математическая модель подзадания в

#my_par([
  Данный код реализует побитовый вывод числа с использованием маски
для итеративной проверки каждого бита, начиная с самого старшего.
])

#my_par([
  Переменной x присваивается значение 25, что в двоичной системе
соответствует `00000000000000000000000000011001` (для 32-битного числа).
Далее переменная n задается как количество бит в переменной типа int,
которое вычисляется через умножение размера `int` (32) на 8. Переменной mask
присваивается значение, равное сдвигу единицы влево на позицию,
соответствующую старшему биту числа x (в данном случае, 31-й бит). Код
последовательно выводит побитовое представление числа. На каждой
итерации побитовой операции И ($"x " amp "mask"$) проверяется, установлен ли
соответствующий бит числа x. Результат сдвигается вправо на количество
позиций, чтобы вывести его в форме 0 или 1. Маска сдвигается вправо на одну
позицию на каждой итерации, проверяя следующий по порядку бит. Таким
образом, в результате работы программы выводится двоичное представление
числа 25.
])

== Код программы

#my_par([
  Реализуем код этой программы на языке С++. Результат представлен на
рисунке ниже (#check_pic()).
])

#let task_1_3 = raw(read("../src/task_1_3.cpp"))

#figure(
  sourcecode(
    lang: "cpp",
    task_1_3
  ),
  caption: [Реализация кода задачи]
)

#my_par([
  В результате выполнения программа выведет следующее (#check_pic()):
])

#figure(
  sourcecode(
    ```
    Начальный вид маски: 10000000000000000000000000000000
    Вид x: 00000000000000000000000000011001
    Результат: 00000000000000000000000000011001
    ```
  ),
  caption: [Вывод программы]
)

= Задание 2

== Формулировка задачи

#my_par([
  Пусть даны не более 8 чисел со значениями от 0 до 7, например, {1, 0, 5,
7, 2, 4}. Подобный набор чисел удобно отразить в виде 8-разрядной битовой
последовательности `11101101`. В ней единичные биты показывают наличие в
исходном наборе числа, равного номеру этого бита в последовательности
(нумерация с 0 слева). Т.о. индексы единичных битов в битовом массиве – это
и есть числа исходной последовательности.
])

#my_par([
  Последовательное считывание бит этой последовательности и вывод
индексов единичных
битов позволит естественным образом получить
исходный набор чисел в отсортированном виде – {0, 1, 2, 4, 5, 7}.
])

#my_par([
  В
качестве подобного битового
массива
удобно использовать
беззнаковое однобайтовое число (его двоичное представление в памяти),
например, типа `unsigned char`. Приёмы работы с отдельными битами числа
были рассмотрены в предыдущем задании.
])

== Математическая модель подзадания а

#my_par([
  Программа начинает с запроса у пользователя количества чисел,
которые он собирается ввести. Это количество должно находиться в пределах
от 1 до 8. Если введено некорректное значение, программа повторно
запрашивает ввод, пока не будет введено корректное число.
])

#my_par([
  Затем программа запрашивает ввод чисел в диапазоне от 0 до 7. Каждое
введённое число добавляется в специальную переменную с использованием
побитовой операции ИЛИ и сдвига. В результате числа представляются как
биты в переменной типа `unsigned char`, где каждый бит соответствует одному
числу. После завершения ввода программа проходит по каждому биту этой переменной и проверяет, какие биты установлены (то есть, какие числа были
введены). В итоге выводятся уникальные числа в порядке возрастания, на
основе установленных битов.
])

== Код программы

#let task_2_1 = raw(read("../src/task_2_1.cpp"))

#my_par([
  Реализуем код этой программы на языке С++. Результат представлен на
рисунке ниже (#check_pic()).
])

#figure(
  sourcecode(
    task_2_1,
    lang: "cpp"
  ),
  caption: [Реализация кода задачи]
)

#my_par([
  В результате выполнения программа выведет следующее (#check_pic()):
])

#figure(
  sourcecode(
    ``` 
      Введите количество чисел в массиве (от 1 до 8)
      6
      Введите 1 число (от 0 до 7)
      1
      Введите 2 число (от 0 до 7)
      0
      Введите 3 число (от 0 до 7)
      5
      Введите 4 число (от 0 до 7)
      7
      Введите 5 число (от 0 до 7)
      2
      Введите 6 число (от 0 до 7)
      4
      0 1 2 4 5 7
    ```
  ),
  caption: [Вывод программы]
)

#my_par([
  Заметим, что
последовательность
приведена в 
корректно
отсортированном порядке.
])

== Математическая модель подзадания б

#my_par([
  Программа начинает с того, что запрашивает у пользователя количество
чисел, которые он хочет ввести, при этом количество должно быть в диапазоне
от 1 до 64. Если ввод некорректен, программа повторяет запрос, пока не будет
введено корректное значение.
])

#my_par([
  Затем программа последовательно запрашивает сами числа, которые
должны находиться в диапазоне от 0 до 63. Каждое число сохраняется в виде
битовой маски, где позиция установленного бита соответствует введённому
числу. Для этого используется операция побитового сдвига и ИЛИ, которая
устанавливает нужный бит в переменной. После ввода всех чисел программа проверяет, какие биты в переменной установлены (то есть какие числа были
введены). Она выводит эти числа в порядке возрастания на основе позиций
установленных битов, что фактически представляет собой отсортированный
вывод введённых чисел.
])

== Код программы

#my_par([
  Реализуем код этой программы на языке С++. Результат представлен на
рисунке ниже (#check_pic()).
])

#let task_2_2 = raw(read("../src/task_2_2.cpp"))

#figure(
  sourcecode(
    lang: "cpp",
    task_2_2
  )
)

#my_par([
  Подадим на вход алгоритма последовательность длины 6 вида {1, 52, 62, 37, 51, 1}. В результате выполнения программа выведет следующее (#check_pic()):
])

#figure(
  sourcecode(
    ```
    Введите количество чисел в массиве (от 1 до 64)
    6
    Введите 1 число (от 0 до 63)
    1
    Введите 2 число (от 0 до 63)
    52
    Введите 3 число (от 0 до 63)
    99
    Ошибка: число не принадлежит диапазону!
    Введите 3 число (от 0 до 63)
    62
    Введите 4 число (от 0 до 63)
    37
    Введите 5 число (от 0 до 63)
    51
    Введите 6 число (от 0 до 63)
    1
    1 37 51 52 62
    ```
  ),
  caption: [Вывод программы]
)

#my_par([
  Заметим, что
последовательность
приведена в 
корректно
отсортированном порядке.
])

== Математическая модель подзадания в

#my_par([
  Программа начинается с ввода количества чисел, которые будут записаны в массив, с проверкой, что это число находится в диапазоне от 1 до 64. 
  Если введено некорректное значение, программа продолжает запрашивать ввод, пока не будет введено корректное.
])

#my_par([
  Затем создаётся массив из 8 элементов типа `unsigned char`, каждый из
которых представляет собой 8 бит (итого 64 бита), чтобы хранить числа в
диапазоне от 0 до 63. Пользователь вводит числа одно за другим, и программа
сохраняет эти числа в массив, используя побитовые операции. Для каждогочисла определяется соответствующий элемент массива и устанавливается бит,
соответствующий номеру введённого числа.
])

#my_par([
  После ввода всех чисел программа проверяет массив, определяя, какие
биты установлены. Для каждого установленного бита выводится его индекс,
что соответствует введённому числу. Таким образом, программа выводит
отсортированный список уникальных чисел, введённых пользователем.
])

== Код программы

#my_par([
  Реализуем код этой программы на языке С++. Результат представлен на
рисунке ниже (#check_pic()).
])

#let task_2_3 = raw(read("../src/task_2_3.cpp"))

#figure(
  sourcecode(
    lang: "cpp",
    task_2_3
  ),
  caption: [Реализация кода задачи]
)

#my_par([
  Подадим на вход алгоритма последовательность длины 7 вида {13, 24, 62,
58, 52, 23, 37}. В результате выполнения программа выведет следующее (#check_pic()):
])

#figure(
  sourcecode(
    ```
    Введите количество чисел в массиве (от 1 до 64)
    7
    Введите 1 число (от 0 до 63)
    13
    Введите 2 число (от 0 до 63)
    24
    Введите 3 число (от 0 до 63)
    62
    Введите 4 число (от 0 до 63)
    58
    Введите 5 число (от 0 до 63)
    52
    Введите 6 число (от 0 до 63)
    23
    Введите 7 число (от 0 до 63)
    37
    13 23 24 37 52 58 62
    ```
  ),
  caption: [Вывод программы]
)

= Задание 3

== Формулировка задачи

#my_par([
  На практике может возникнуть задача внешней сортировки, т.е.
упорядочения значений, расположенных во внешней памяти компьютера,
размер которых превышает допустимый объём ОЗУ (например, 1 МБ стека,
выделяемый по умолчанию программе операционной системой).
])

#my_par([
  Возможный способ – это алгоритм внешней сортировки слиянием,
рассмотренный в одной из предыдущих практических работ. Считывание
исходного файла при этом происходит один раз, но в процессе сортировки
создаются и многократно считываются вспомогательные файлы, что
существенно снижает быстродействие.
])

#my_par([
  Второй возможный приём – считывание входного файла порциями,
размер каждой из которых не превышает лимит ОЗУ. Результат записываетсяв выходной файл за один раз, при этом не используются вспомогательные
файлы. Программа будет работать быстрее, но всё-таки есть алгоритм,
существенно превосходящий перечисленные.
])

#my_par([
  Реализовать
высокоэффективную
сортировку
большого
объёма
числовых данных в файле можно на идее битового массива. Достаточно один
раз считать содержимое файла, заполнив при этом в памяти ЭВМ битовый
массив и на его основе быстро сформировать содержимое выходного файла в
уже отсортированном виде.
])

#my_par([
  При использовании битового массива для представления сортируемых
чисел, программу можно представить как последовательность из трех
подзадач: #enum(
  numbering: "a.",
  [Создание битового массива с нулевыми исходными значениями.],
  [Считывание целых чисел из файла и установка в 1 соответствующих
бит массива.],
  [Формирование
упорядоченного
выходного
файла
путём
последовательной проверки бит массива и вывода в файл номеров (индексов)
тех бит, которые установлены в 1.]
)
])

== Математическая модель алгоритма

#my_par([
  Программа начинается с открытия файла, в котором хранятся
неотсортированные числа. Затем она создаёт структуру данных, состоящую из
битовых масок, где каждый бит будет соответствовать одному числу в
заданном диапазоне. Программа читает каждое число из входного файла и
устанавливает соответствующий бит в созданной структуре. После обработки
всех чисел она открывает новый файл для записи отсортированных чисел.
Программа проходит по битовой структуре, проверяет, какие биты
установлены, и записывает соответствующие числа в выходной файл в
отсортированном порядке. В завершение программа измеряет время,
затраченное на выполнение задачи, и рассчитывает объём памяти,использованный для хранения битовой структуры, выводя обе эти
информации на экран.
])

== Код программы

#my_par([
  Реализуем код этой программы на языке С++. Результат представлен на
рисунке ниже (#check_pic()).
])

#let task_3 = raw(read("../src/task_3.cpp"))

#figure(
  sourcecode(
    lang: "cpp",
    task_3
  ),
  caption: [Реализация кода задачи]
)

#my_par([
  Запустим данный код, предварительно разместив в файле 100
случайных неповторяющихся чисел в диапазоне от 1000000 до 9999999 (#check_pic()).
])

#let input = raw(read("../examples/input.txt"))

#figure(
  sourcecode(
    input
  ),
  caption: [Входные данные (первые 10 чисел)]
)

#my_par([
  После обработки программой данного файла, получился новый файл с
отсортированными данными (#check_pic())
])

#let output = raw(read("../examples/output.txt"))

#figure(
  sourcecode(
    output
  ),
  caption: [Отсортированные данные (первые 10 строк)]
)

#my_par([
  Заметим, что
последовательность
приведена в 
корректно
отсортированном порядке.
])

#my_par([
  Выполнение данного кода затратило следующие ресурсы (#check_pic())
])

#figure(
  sourcecode(
    ```
    Время выполнения: 0.185147 секунд
    Использовано памяти: 1125000 байт
    ```
  ),
  caption: [Затраченные ресурсы]
)

#pagebreak()

= Выводы

#my_par([
  В рамках выполненной практической работы цель по освоению приёмов работы с битовым представлением беззнаковых целых чисел и реализации эффективного алгоритма внешней сортировки на основе битового массива была успешно достигнута. 
Написанные программы продемонстрировали
эффективность использования битового представления для хранения и обработки больших объёмов данных. Реализованный алгоритм внешней сортировки с использованием битового массива показал высокую эффективность в обработке и сортировке чисел.
Были освоены основы работы с битовым представлением беззнаковых целых чисел.
])
