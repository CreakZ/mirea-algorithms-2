#import "assets/title_page.typ": title_page_me

#import "@preview/codelst:2.0.2": sourcecode

#set text(font: "New Computer Modern", size: 14pt)
#set page(margin: 2cm)
#set heading(numbering: "1.1.1.")
#set figure(supplement: [Рисунок])
#set figure.caption(separator: [ -- ])

#show heading: it => align(center, it)

#title_page_me(
  8.1,
  [Алгоритмы кодирования и сжатия данных]
)

#outline(
  title: [Оглавление]
)

#set page(numbering: "1")
#set par(
  justify: true
)

*Цель работы:* изучить важные задачи теории графов

= Задание 1

== Формулировка задач

#let wrap(text) = {
  [$quote.angle.double.l$#text$quote.angle.double.r$]
}

#enum(
  [Закодировать фразу методами Шеннона–Фано: \ $quote.angle.double.l$Дрынцы-брынцыбубенцы, Раззвонились удальцы, Диги-диги-диги-дон, Выхо-ди-скорее-вон!$quote.angle.double.r$],
  [Сжатие данных по
методу Лемпеля–Зива LZ77. Используя
двухсимвольный
алфавит (0, 1)
закодировать
следующую фразу: \ #wrap(1110100110111001101)],
  [Закодировать следующую
фразу, используя код LZ78: \ #wrap([sionsinossionsinos])]
)

#pagebreak()

== Кодирование фразы методом Шеннона–Фано

Подсчитаем число вхождений всех символов и выпишем эти значения в таблицу в порядке убывания

#figure(
  table(
    columns: 2,
    align: (left, left),
    table.header(
      [*Символ*], [*Частота*]
    ),
    [и], [8],
    [пробел], [8],
    [Д], 	[7],
    [ы], 	[6],
    [н], 	[6],
    [ц], 	[6],
    [-], 	[5],
    [б], 	[4],
    [у], 	[4],
    [е], 	[4],
    [з], 	[4],
    [,], 	[3],
    [в], 	[3],
    [о], 	[3],
    [г], 	[3],
    [а], 	[2],
    [р], 	[2],
    [л], 	[2],
    [с], 	[2],
    [Р], 	[1],
    [х], 	[1],
    [к], 	[1],
    [!], 	[1],
  )
)

Произведем разбиение символов на две группы с равными суммами частот:
Группа 1: {и, пробел, Д, ы, н, ц, б}. Сумма частот: 45. \
Группа 2: {-, у, е, з, , , в, о, г, а, р, л, с, Р, х, к, !}. Сумма частот: 44.

Теперь присвоим коды всем символам. Символы первой группы получают префикс `0`, символы второй группы -- `1`. Полученный результат представим в таблице.

#figure(
  table(
    columns: 2,
    align: (left, left),
    table.header(
      [*Символ*], [*Код*]
    ),
    [пробел], [`0001`],
    [!], [`000000`],
    [,], [`10101`],
    [-], [`010`],
    [В], [`000001`],
    [Д], [`00001`],
    [Р], [`1101011`],
    [а], [`111110`],
    [б], [`10011`],
    [в], [`111111`],
    [г], [`11001`],
    [д], [`1000`],
    [е], [`11000`],
    [з], [`10010`],
    [и], [`011`],
    [к], [`110100`],
    [л], [`110110`],
    [н], [`1011`],
    [о], [`0011`],
    [р], [`10100`],
    [с], [`00101`],
    [у], [`00100`],
    [х], [`1101010`],
    [ц], [`11110`],
    [ы], [`1110`],
    [ь], [`110111`],
  )
)

Теперь перепишем исходный текст, заменяя символы на соответствующие им двоичные коды. В результате данного процесса получится:

```
000011010011101011111101110010100111010011101011111101110100110010010011110
001011010111101110101010001110101111111010010010100101111110011101101111011
001100101110111000100100100011111011011011011111110111010101000100001011110
010110101000011110010110101000011110010110101000001110111010100010000011110
110101000110101000011010001011101000011101001100011000010111111001110110000
00
```

Длина полученного текста составляет 377 бит. Длина исходного текста -- $85 times 8 = 680$ бит. Коэффициент сжатия текста составляет #{str(680/377).slice(0, 7)}.

#pagebreak()

== Сжатие данных методом LZ77

Произведём сжатие строки с использованием алгоритма LZ77. Для этого разобьём процесс на несколько шагов:

1. Установим окно поиска (часть текста перед текущей позицией) и буфер просмотра (необработанная часть текста). Окно поиска ограничим определённым размером для удобства работы.

2. Будем последовательно проверять, содержится ли начало строки из буфера просмотра в окне поиска. Если совпадение найдено, определим его смещение (расстояние назад) и длину (количество совпадающих символов).

3. Если совпадение не найдено, зафиксируем тройку вида `(0, 0, символ)`, где символ — это первый символ из буфера просмотра.

4. После определения совпадения или фиксации символа, сдвинем буфер просмотра на длину совпадения плюс один символ и повторим процесс, пока вся строка не будет обработана.

5. Результатом будет набор троек `(offset, length, next_symbol)`, представляющих сжатую строку.

Приведем результат всех итераций в качестве таблицы.

#table(
  columns: 4,
  align: left,
  table.header(
    [Позиция], [Найденная подстрока], [Тройка `(offset, length, next_symbol)`], [Закодированная часть],
  ),
  [0], [–], [`(0, 0, 1)`], [`1`],
  [1], [`1`], [`(1, 1, 1)`], [`11`],
  [3], [–], [`(0, 0, 0)`], [`0`],
  [4], [`11`], [`(2, 2, 0)`], [`1100`],
  [8], [`1100`], [`(6, 4, 1)`], [`11001111`],
  [12], [`11001111`], [`(8, 5, 0)`], [`1100111100000`],
  [17], [`0`], [`(10, 1, )`], [`0`],
)

#pagebreak()

== Сжатие данных методом LZ78

Произведём сжатие строки с использованием алгоритма LZ78. Для этого будем работать с динамически пополняемым словарём, содержащим подстроки, встречающиеся в тексте. Процесс работы алгоритма разбивается на следующие шаги:

1. Начнём с пустого словаря. Входная строка будет считываться последовательно символ за символом.

2. На каждом шаге будем искать самую длинную подстроку, которая уже есть в словаре. Если такая подстрока найдена, она будет зафиксирована как элемент токена.

3. Определим следующую пару:
   - `index` — индекс найденной подстроки в словаре (или `0`, если подстрока не найдена).
   - `next_symbol` — символ, который идёт сразу после найденной подстроки.

4. Добавим новую подстроку (найденная подстрока + `next_symbol`) в словарь, увеличив его размер.

5. Повторим процесс, пока вся строка не будет обработана.

6. Результатом будет последовательность пар `(index, next_symbol)`, которая представляет сжатую строку. Эти пары можно использовать для восстановления исходного текста.

Приведем результат всех итераций в качестве таблицы.

#table(
  columns: 6,
  align: left,
  table.header(
    [Шаг], [Текущая подстрока], [Найдена в словаре?], [(index, \ next_symbol)], [Добавляем в словарь], [Новый словарь]
  ),
  [1], [s], [Нет], [(0, s)], [s], [1: s],
  [2], [i], [Нет], [(0, i)], [i], [2: i],
  [3], [o], [Нет], [(0, o)], [o], [3: o],
  [4], [n], [Нет], [(0, n)], [n], [4: n],
  [5], [si], [Да (1)], [(1, i)], [si], [5: si],
  [6], [io], [Да (4)], [(4, o)], [io], [6: io],
  [7], [so], [Да (1)], [(1, s)], [so], [7: so],
  [8], [io], [Да (2)], [(2, o)], [ioo], [8: ioo],
  [9], [os], [Да (4)], [(4, s)], [os], [9: os],
  [10], [in], [Да (2)], [(2, n)], [inn], [10: inn],
  [11], [s], [Да (3)], [(3, s)], [ss], [11: ss]
)

#pagebreak()

= Задание 2 

== Код программ

=== Алгоритм Шеннона–Фано

Приведем ниже программную реализацию алгоритма Шеннона–Фано на языке программирования С++.

#let shannon = raw(read("work_8-1/shennon_fano.cpp"), lang: "cpp")

#sourcecode(shannon)

#pagebreak()

=== Алгоритм LZ77

Приведем ниже программную реализацию алгоритма LZ77 на языке программирования С++.

#let lz77 = raw(read("work_8-1/lz77.cpp"), lang: "cpp")

#sourcecode(lz77)

#pagebreak()

=== Алгоритм LZ78

Приведем ниже программную реализацию алгоритма LZ78 на языке программирования С++.

#let lz78 = raw(read("work_8-1/lz78.cpp"), lang: "cpp")

#sourcecode(lz78)

#pagebreak()

== Тестирование

Для проверки корректности работы алгоритмов Шеннона-Фано, LZ77 и LZ78 проведём тестирование на строках, данных в качестве исходных для персонального варианта. Для каждого алгоритма будут выполнены сжатие данных и последующее восстановление исходной строки. Это позволит убедиться, что алгоритмы работают корректно и производят идентичное восстановление текста.

Для алгоритма Шеннона-Фано исходная строка: `Дрынцы-брынцыбубен-цы, Раз-звонились удальцы, Диги-диги-диги-дон, Выхо-ди-скорее-вон!`

В результате выполнения программы с данными входными данными получается следующий результат:

#figure(
  image("work_8-1/img/test-1.png")
)

Для алгоритма LZ77 исходная строка: `1110100110111001101`

В результате выполнения программы с данными входными данными получается следующий результат:

#figure(
  image("work_8-1/img/test-2.png", width: 60%)
)

Для алгоритма LZ78 исходная строка: `sionsinossionsinos`

В результате выполнения программы с данными входными данными получается следующий результат:

#figure(
  image("work_8-1/img/test-3.png")
)

#pagebreak()

= Вывод

В ходе данной работы были изучены и реализованы три алгоритма сжатия данных: Шеннона-Фано, LZ77 и LZ78. Было проведено сжатие вручную для тестовых строк, а затем разработаны программные решения для автоматизации процесса, что позволило оценить корректность алгоритмов и их практическое применение.

На первом этапе сжатие было выполнено вручную. Для алгоритма Шеннона-Фано были рассчитаны частоты символов и построены префиксные коды, которые позволили уменьшить объём данных за счёт неравномерного кодирования. Алгоритмы LZ77 и LZ78 были также реализованы вручную: строки были разобраны на токены, представляющие повторяющиеся подстроки и символы, что позволило наглядно увидеть принципы их работы.

На втором этапе были созданы программные реализации всех трёх алгоритмов. Программа сжимала строку, создавая соответствующие коды или токены, а затем выполняла декодирование для проверки корректности сжатия. Результаты показали, что автоматизированные алгоритмы работают точно и позволяют эффективно сжимать строки с восстановлением исходных данных.
