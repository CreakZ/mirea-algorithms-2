#import "assets/title_page.typ": title_page_me

#import "@preview/codelst:2.0.2": sourcecode

#set text(font: "New Computer Modern", size: 14pt)
#set page(margin: 2cm)
#set heading(numbering: "1.1.1.")
#set figure(supplement: [Рисунок])
#set figure.caption(separator: [ -- ])

#show heading: it => align(center, it)

#let indent = 1.25cm

#title_page_me(
  8.2,
  [Реализация алгоритмов на основе сокращения числа переборов]
)

#outline(
  title: [Оглавление]
)

#set page(numbering: "1")
#set par(
  justify: true
)

#h(indent) *Цель работы:* изучить важные задачи теории графов

= Формулировка задачи

#enum([Разработать алгоритм решения задачи с применением метода, указанного
в варианте и реализовать программу.],
[Оценить количество переборов при решении задачи стратегией «в лоб» -
грубой силы. Сравнить с числом переборов при применении метода.],
[Оформить отчет в соответствии с требованиями документирования разра-
ботки ПО: постановка задачи, описание алгоритмов и подхода к решению, код, результаты тестирования, вывод.])

#h(indent) Задача моего персонального варианта: \
#h(indent) Монетная система некоторого государства состоит из монет достоинством $a_1 = 1 < a_2 < dots < a_n$. Требуется выдать сумму наименьшим возможным количеством монет.

#pagebreak()

= Описание алгоритмов

== Алгоритм полного перебора

#h(indent) Алгоритма полного перебора для подбора сдачи минимальным числом монет заключается в переборе всех возможных способов составления суммы. Алгоритм работает следующим образом: для каждой монеты из доступного набора проверяется, что произойдет, если её использовать для уменьшения текущей суммы. Затем задача сводится к нахождению минимального числа монет для оставшейся суммы. Это повторяется рекурсивно, пока сумма не станет равной нулю. Если сумма уходит в отрицательное значение, этот путь отбрасывается как недопустимый. На каждом этапе фиксируется минимальное количество монет среди всех возможных комбинаций. Этот метод рассматривает все возможные варианты и гарантирует нахождение оптимального решения, но его вычислительная сложность очень высока из-за экспоненциального роста числа комбинаций.

#h(indent) Приведем код решения задачи варианта алгоритмом полного перебора на языке программирования С++

#figure(
  image("work_8-2/img/4.png"),
  caption: [Код алгоритма полного перебора на языке С++]
)

#h(indent) Протестируем код на множестве монет {1, 5, 10, 25}. Допустим, требуется выдать сдачу на сумму 63 монеты. Результат работы кода: 

#figure(
  image("work_8-2/img/1.png"),
  caption: [Тест №1]
)

== Жадный алгоритм

#h(indent) Жадный алгоритм для подбора сдачи минимальным количеством монет заключается в том, чтобы на каждом шаге выбирать монету с наибольшим номиналом, которая не превышает текущую оставшуюся сумму. После выбора монеты текущая сумма уменьшается на её номинал, и процесс повторяется до тех пор, пока сумма не станет равной нулю. Если после прохождения всех монет сумму выдать не удается, алгоритм сообщает, что решение невозможно.

#h(indent) Этот подход эффективен благодаря своей простоте и скорости, так как он не перебирает все возможные комбинации монет, а сразу принимает локально оптимальные решения. Жадный алгоритм всегда корректен в тех случаях, когда система монет каноническая (например, монеты 1, 5, 10, 25, где каждая монета кратна всем меньшим). Однако в некоторых случаях (например, монеты 1, 3, 4) он может дать неоптимальный результат, так как не учитывает все возможные комбинации монет.

#h(indent) Приведем код решения задачи варианта жадным алгоритмом на языке программирования С++

#figure(
  image("work_8-2/img/3.png"),
  caption: [Код жадного алгоритма на языке С++]
)

#h(indent) Протестируем код на множестве монет {1, 5, 10, 25}. Допустим, требуется выдать сдачу на сумму 63 монеты. Результат работы кода: 

#figure(
  image("work_8-2/img/2.png"),
  caption: [Тест №2]
)

== Оценка сложностей алгоритмов

#h(indent) Оценка сложности полного перебора показывает, что этот подход имеет экспоненциальную временную сложность $O(n^"amount")$, где $n$ — количество типов монет, а $"amount"$ — сумма, которую нужно выдать. Это объясняется тем, что для каждой суммы перебираются все возможные монеты, что приводит к огромному числу рекурсивных вызовов. Пространственная сложность ограничивается глубиной рекурсии и составляет $O("amount")$. Из-за экспоненциальной сложности этот метод становится практически неприменимым для больших сумм, хотя он всегда находит оптимальное решение.

#h(indent) Жадный алгоритм имеет гораздо более низкую временную сложность $O(n log n)$, если требуется сортировка монет, или $O(n)$, если монеты уже отсортированы. Это связано с тем, что алгоритм просто проходит по списку монет, начиная с самой крупной, и выбирает их до тех пор, пока сумма не будет выдана. Пространственная сложность равна $O(1)$, если сортировка выполняется на месте, что делает жадный алгоритм очень эффективным с точки зрения использования памяти. Однако он может не найти оптимальное решение в системах монет, где крупные номиналы не всегда обеспечивают минимальное число монет, что является его основным ограничением.

#pagebreak()

= Вывод

#h(indent) В ходе выполнения работы были исследованы два подхода к решению задачи подбора сдачи минимальным количеством монет: метод полного перебора и жадный алгоритм. Метод полного перебора, хотя и гарантирует нахождение оптимального решения, имеет экспоненциальную сложность, что делает его непрактичным для больших значений суммы и большого количества номиналов монет. С другой стороны, жадный алгоритм продемонстрировал высокую эффективность с точки зрения времени выполнения благодаря линейной или логарифмической сложности. Однако его основное ограничение заключается в том, что он не всегда находит оптимальное решение для систем монет, не являющихся каноническими.

#h(indent) Таким образом, выбор подхода зависит от характеристик задачи. Для небольших входных данных и высокой важности нахождения точного результата может быть предпочтителен метод полного перебора. Для задач с большими суммами и каноническими наборами монет более рационально использовать жадный алгоритм. Эти выводы подтверждают, что в различных сценариях необходимо выбирать метод, который лучше всего соответствует требованиям конкретной задачи.
