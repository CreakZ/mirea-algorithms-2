#import "assets/title_page.typ": title_page_me

#import "@preview/codelst:2.0.2": sourcecode

#set text(font: "New Computer Modern", size: 14pt)
#set page(margin: 2cm)
#set heading(numbering: "1.1.1.")
#set figure(supplement: [Рисунок])
#set figure.caption(separator: [ -- ])

#show heading: it => align(center, it)

#title_page_me(
  7.2,
  [Графы: создание, алгоритмы обхода, важные задачи теории графов]
)

#outline(
  title: [Оглавление]
)

#set page(numbering: "1")
#set par(
  justify: true
)

#pagebreak()

*Цель работы:* изучить важные задачи теории графов

= Выполнение работы

== Формулировка задачи

Реализовать построение минимального остовного дерева при помощи алгоритма Прима.

== Математическая модель

Алгоритм Прима предназначен для построения минимального остовного дерева $T$ связного взвешенного графа $G = (V,E)$, где $V$ — множество вершин, $E$ — множество рёбер с весами $w:E->R#super([+])$. Алгоритм начинается с произвольной вершины $v_0 in V$, которой присваивается ключевой вес $"key"[v] = 0$. 
Для всех остальных вершин $v in V \\ {v_0}$ их ключевые веса инициализируются как $"key"[v]=infinity$. 
На каждом шаге алгоритм выбирает вершину  $v in V \\ T$, обладающую минимальным ключевым весом. Эта вершина добавляется в остовное дерево 
$T$.

После добавления вершины $u$, для каждой соседней вершины $v$, связанной с $u$ ребром $e=(u,v) in E$, проверяется условие:

$ w(u,v) < "key"[v] $

Если оно выполняется, то ключевой вес вершины обновляется:

$ "key"[v]=w(u,v), $
а вершина u записывается как родитель вершины v в дереве:

$ "parent"[v]=u $

Процесс повторяется $abs(V) - 1$ раз, пока все вершины не будут включены в дерево T. 

В результате получается минимальное остовное дерево.

== Код программы

Приведем код, реализующий алгоритм Прима на языке программирования С++, ниже

#let source = raw(read("work_7-2/main.cpp"), lang: "cpp")

#sourcecode(
  frame: none,
  source
)

== Тестирование

=== Тест №1

В качестве теста №1 приведен данный в формулировке задания граф (см. рис. 1).

#figure(
  image(
    "work_7-2/assets/graph_1.png",
    width: 50%
  ),
  caption: [Граф №1]
)

В результате работы программы получается следующий вывод (см. рис. 2)

#figure(
  image(
    "work_7-2/assets/output_1.png",
    width: 70%
  ),
  caption: [Вывод программы для входных данных теста №1]
)

Вывод соответствует следующему минимальному остовному дереву (см. рис. 3)

#figure(
  image(
    "work_7-2/assets/graph_1_span.png",
    width: 50%
  ),
  caption: [Граф №1]
)

#pagebreak()

=== Тест №2

В качестве теста №2 приведем следующий граф (см. рис. 4).

#figure(
  image(
    "work_7-2/assets/graph_2.png",
    width: 50%
  ),
  caption: [Граф №2]
)

В результате работы программы получается следующий вывод (см. рис. 5)

#figure(
  image(
    "work_7-2/assets/output_2.png",
    width: 70%
  ),
  caption: [Вывод программы для входных данных теста №2]
)

#pagebreak()

Вывод соответствует следующему минимальному остовному дереву (см. рис. 6)

#figure(
  image(
    "work_7-2/assets/graph_2_span.png",
    width: 50%
  ),
  caption: [Граф №1]
)

=== Тест №3

В качестве теста №2 приведем следующий граф, уже являющийся деревом, веса всех ребер которого равны 1 (см. рис. 4).

#figure(
  image(
    "work_7-2/assets/graph_3.png",
    width: 50%
  ),
  caption: [Граф №3]
)

#pagebreak()

В результате работы программы получается следующий вывод (см. рис. 5). Как видно из полученного результата, мы получили исходный граф.

#figure(
  image(
    "work_7-2/assets/output_3.png",
    width: 70%
  ),
  caption: [Вывод программы для входных данных теста №3]
)

#pagebreak()

= Вывод

В ходе выполнения практической работы был изучен алгоритм Прима для построения минимального остовного дерева связного взвешенного графа. Были исследованы теоретические основы алгоритма, включая его жадный подход к выбору рёбер с минимальным весом на каждом шаге.

В процессе работы была реализована программа на языке C++, позволяющая находить минимальное остовное дерево для произвольного графа. В качестве метода хранения графа в памяти была использована матрица смежности. Программа предусматривает ввод графа с клавиатуры в формате списка рёбер, что обеспечивает её универсальность и возможность работы с различными графами.

Были проведены тестовые прогоны программы на 3-х заданных графах, в результате чего были получены минимальные остовные деревья. Результаты подтвердили корректность реализации и соответствие алгоритма его теоретической модели.
