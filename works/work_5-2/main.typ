#import "../../assets/alter_title_page.typ": *

#import "@preview/codelst:2.0.1": *
#import "@preview/lovelace:0.3.0": *

#set text(size: 14pt, font: "New Computer Modern")
#set heading(numbering: "1.1.1.")
#set page(margin: 2cm)
#set figure(supplement: [Рисунок])
#set figure.caption(separator: [ -- ])

#show heading: it => align(center, it)

#let indent = h(1.25cm)

#title_page_me(
  5.2,
  [Работа с данными из файла]
)

#outline(
  title: [Оглавление]
)

#pagebreak()

#set par(justify: true, first-line-indent: 1.25cm)
#set page(numbering: "1")

= Задание 1

== Постановка задачи

#indent Создать двоичный файл из записей (структура записи определена
вариантом). Поле ключа записи в задании варианта подчеркнуто. Заполнить
файл данными, используя для поля ключа датчик случайных чисел. Ключи
записей в файле уникальны. Рекомендация: создайте сначала текстовый файл,
а затем преобразуйте его в двоичный.

== Структура записи файла

#indent Каждая запись в файле представляет собой строку следующего вида:

```
Номер_аккаунта;Имя_владельца_аккаунта;Адрес_владельца_аккаунта
```

#indent Пример конкретной строки можно увидеть ниже (для наглядности после точки с запятой расставлены переносы строк, однако в исходных файлах переносы строк отсутствуют):

```
6780660;
Евгений Геркулесов;
Россия, г. Владивосток, Приозерная ул., д. 18 кв.17
```

== Алгоритмы, которые реализуются в форме функций

#indent Алгоритм генерации случайной информации об аккаунтах генерирует случайное число из диапазона $[1000000;9999999]$, являющееся номером банковского аккаунта. Затем из заранее определенных массивов с фамилиями и именами случайным образом выбирается пара `имя фамилия`. В конце аналогично случайным образом выбирается адрес владельца банковского аккаунта.

== Код программы

#let generator_code = raw(read("../examples/generator_code.txt"), lang: "cpp")

#sourcecode(generator_code)

== Пример работы

#indent Ниже представлен пример генерации текстового файла (`.txt`).

#let data = read("../examples/generated_data.example.txt")

#{
  set par(first-line-indent: 0cm)
  raw(data)
}

#pagebreak()

#indent Помимо текстового файла так же создается и бинарный файл (`.bin`, см. рис. 2).

#figure(
  image("img/generated_data.png"),
  caption: [Сгенерированная информация]
)

= Задание 2

== Постановка задачи

#indent Разработать программу поиска записи по ключу в бинарном файле с применением алгоритма линейного поиска.

== Алгоритм линейного поиска записи в файле на псевдокоде

#indent Функция `linear_search(accounts, account_number)`, где `accounts` -- вектор, содержащий информацию о всех банковских аккаунтах, `account_number` -- номер искомого банковского аккаунта

#figure(
  pseudocode-list[
    + `for-each` цикл `acc : accounts`
      + если `acc.account_number` $=$ account_number
        + вернуть ссылку на `acc`

    + вернуть нулевой указатель
  ],
  supplement: [Фрагмент псевдокода],
  caption: [Псевдокод алгоритма бинарного поиска]
)

== Код программы линейного поиска записи по ключу

#let linear_search = raw(read("../examples/linear_search.txt"), lang: "cpp")

#sourcecode(linear_search)

== Результат тестирования алгоритма 

#figure(
  table(
    columns: 2,
    table.header(
      [Количество записей], [Время выполнения, `нс`]
    ),
    [100], [5727],
    [1000], [18787],
    [10000], [112442],
  ),
  supplement: [Таблица],
  caption: [Время выполнения линейного поиска для 100, 1000 и 10000 записей]
)

= Задание 3

==  Постановка задачи

#indent Разработать программу поиска записи по ключу в бинарном файле с применением алгоритма бинарного поиска (алгоритм поиска определен вариантов, в данном случае, вариантом №18).

== Алгоритм бинарного поиска 

#indent Функция `binary_search(accounts, account_number)`, где `accounts` -- вектор, содержащий информацию о всех банковских аккаунтах, `account_number` -- номер искомого банковского аккаунта

#figure(
  pseudocode-list[
    + `left` $<-$ 0
    + `right` $<-$ len(`accounts`) $-$ 1
    + пока `left` $<=$ `right`
      + `mid` $<-$ `left` + (`right` - `left`) $div$ 2
      + если `accounts`[`mid`].`account_number` = `account_number`
        + вернуть ссылку на `accounts`[`mid`]
      + если `accounts`[`mid`].`account_number` $<$ `account_number` 
        + `left` $<-$ `mid` $+$ 1
      + иначе
        + `right` $<-$ `mid` $-$ 1
    + вернуть нулевой указатель
  ],
  supplement: [Фрагмент псевдокода],
  caption: [Псевдокод функции бинарного поиска]
)

#pagebreak()

== Код функции поиска

#let binary_search = raw(read("../examples/binary_search.txt"), lang: "cpp")

#sourcecode(binary_search)

== Результат тестирования алгоритма

#figure(
  table(
    columns: 2,
    table.header(
      [Количество записей], [Время выполнения, `нс`]
    ),
    [100], [1886],
    [1000], [2375],
    [10000], [2794],
  ),
  supplement: [Таблица],
  caption: [Время выполнения бинарного поиска для 100, 1000 и 10000 записей]
)

#pagebreak()

= Анализ эффективности алгоритмов

#indent Бинарный поиск (асимптотическая сложность $O(log n)$) намного эффективнее линейного (асимптотическая сложность $O(n)$) на больших объемах данных,  но с условием, что данные отсортированы. Если массив не отсортирован, сначала потребуется выполнить сортировку, что добавляет к времени выполнения сложность $O(n log n)$. Линейный поиск, в свою очередь, проще в реализации и не требует сортировки данных, но значительно медленнее для больших массивов.
