#import "../../assets/title_page.typ": *

#import "@preview/codelst:2.0.1": *

#set text(size: 14pt, font: "New Computer Modern")
#set heading(numbering: "1.1.1.")
#set page(margin: 2cm)

#set figure(supplement: [Рисунок])
#set figure.caption(separator: [ -- ])

#show heading: it => align(center, it)

#title_page_me(
  6.2,
  [Поиск образца в тексте]
)

#outline(
  title: [Оглавление]
)

#set page(numbering: "1")
#set par(justify: true, first-line-indent: 1.25cm)

#pagebreak()

#h(1.25cm) *Цель работы: * изучение и реализация алгоритма Кнута-Морриса-Пратта (КМП) для поиска подстроки в строке, а также анализ его эффективности по сравнению с другими методами поиска.

= Выполнение работы

== Подзадание 1

=== Формулировка задачи

#h(1.25cm) Дано предложение, состоящее из слов. Найти самое длинное слово предложения, первая и последняя буквы которого одинаковы.

=== Математическая модель

#h(1.25cm) Алгоритм принимает на вход строку $S$, представляющую собой предложение без знаков препинания, где слова разделены пробелами. Если строка $S$ пуста, функция сразу возвращает пустую строку.

Далее строка $S$ разбивается на слова, образуя множество W, где каждое слово $w_i ​in W$ представляется как последовательность символов. Для каждого слова из этого множества проверяется, совпадают ли его первый и последний символы. Если это так, данное слово назначается текущим значением результата. После завершения проверки всех слов алгоритм возвращает последнее найденное слово с одинаковыми первым и последним символами. Если таких слов нет, возвращается пустая строка.

=== Код программы

#h(1.25cm) Приведем код вышеописанного алгоритма на языке программирования Go:

#let s = ```go
func longestWordWithCommonFirstLast(text string) string {
	if text == "" {
		return ""
	}

	target := ""
	for _, word := range strings.Split(text, " ") {
		letters := []rune(word)
		if letters[0] == letters[len(letters)-1] {
			if len(word) > len(target) {
				target = word
			}
		}
	}

	return target
}
```

#sourcecode(s)

=== Тестирование

#figure(
  image(
    "img/test_1-1.png",
    width: 60%
  ),
  caption: [Тест №1]
)

#figure(
  image(
    "img/test_1-2.png",
    width: 60%
  ),
  caption: [Тест №2]
)

#figure(
  image(
    "img/test_1-3.png",
    width: 60%
  ),
  caption: [Тест №3]
)

== Подзадание 2

=== Формулировка задачи

#h(1.25cm) Используя алгоритм Кнута-Мориса-Пратта, найти индекс последнего вхождения
образца в текст.

=== Математическая модель

#heading(
  numbering: none,
  outlined: false,
  text(size: 14pt)[Префикс-функция]
)

#h(1.25cm) Пусть s — строка, состоящая из символов s=s1,s2,…,sn. Префикс-функция для строки s, обозначаемая как $pi[i]$, равна длине наибольшего префикса строки s[0:i], совпадающего с её суффиксом. Формально, для каждого i из 
[1,n-1] значение $pi[i]$ — это максимальное число 
k, при котором соблюдается равенство $s[0:k-1]=s[i-k+1:i]$.

Алгоритм вычисления префикс-функции для строки s работает следующим образом:

#enum(
  [Вводится массив $pi$ длиной $n$, где каждое значение инициализируется нулем.],
  [Инициализируем индекс $j = 0$, который указывает на текущую длину совпадающего префикса.],
  [Для каждого i от 1 до n-1: 
- Если текущий символ s[i] не совпадает с s[j], то значение j обновляется до $pi[j-1]$ до тех пор, пока совпадение не найдено или j=0.

- Если символы совпадают, увеличиваем j на 1 и записываем его в $pi[i]$.
],
  [По завершении этого цикла префикс-функция $pi$ готова.]
)

#heading(
  numbering: none,
  outlined: false,
  text(size: 14pt)[Алгоритм Кнута-Морриса-Пратта (КМП-алгоритм)]
)

#h(1.25cm) КМП-алгоритм позволяет находить последнее (что требуется в рамках задания) вхождение строки $p$ (шаблона) в строку $t$ (текста) с использованием предварительно рассчитанной префикс-функции. В данном случае он работает следующим образом:

Пусть $t=t_1,t_2,dots,t_m$ и $p=p_1,p_2,dots,p_n$ -- строки текста и шаблона соответственно. Также обозначим длину шаблона как n и длину текста как m. Алгоритм использует префикс-функцию $pi$ для строки p, чтобы оптимизировать процесс поиска.

#enum(
  [Инициализируем переменные: $j=0$ — индекс текущего совпадающего символа в шаблоне, и $"last"=-1$ — переменная для хранения последнего найденного совпадения.],
  [Для каждого символа $t[i]$ из текста:
  - Если $t[i] != p[j]$, то обновляем $j=pi[j-1]$, пока символы не совпадут или пока $j$ не станет равным нулю
  - Если $t[i]=p[j]$, увеличиваем $j$ на 1

  - Если $j$ достигает значения $n$ (длины шаблона), это значит, что найдено совпадение. Индекс начала совпадения равен $i+1-j$, и он записывается в $"last"$. После этого $j$ обновляется до $pi[j-1]$, чтобы продолжить поиск возможных последующих вхождений шаблона в текст.
  ],
  [По завершении цикла возвращается значение $"last"$, представляющее индекс последнего найденного вхождения шаблона в текст. Если совпадение не найдено, возвращается -1.
Таким образом, алгоритм КМП находит последнее вхождение шаблона в тексте с эффективностью $O(m+n)$, благодаря использованию префикс-функции для уменьшения числа сравнений.]
)

=== Код программы

#h(1.25cm) Приведем код вышеописанного алгоритма на языке программирования Rust:

#let prefix = ```rust
fn prefix_function(s: String) -> Vec<usize> {
  let mut prefix = vec![0; s.len()];
  let mut j = 0;

  for i in 1..s.len() {
      while j > 0 && s.as_bytes()[i] != s.as_bytes()[j] {
          j = prefix[j - 1];
      }
      if s.as_bytes()[i] == s.as_bytes()[j] {
          j += 1;
      }
      prefix[i] = j;
  }

  prefix
}
```

#let kmp = ```rust
fn kmp_search(text: String, pattern: &str) -> Option<usize> {
  let prefix = prefix_function(text.clone());
  let mut last = None;
  let mut j = 0;

  for i in 0..text.len() {
      while j > 0 && text.as_bytes()[i] != pattern.as_bytes()[j] {
          j = prefix[j - 1];
      }
      if text.as_bytes()[i] == pattern.as_bytes()[j] {
          j += 1;
      }
      if j == pattern.len() {
          last = Some(i + 1 - j);
          j = prefix[j - 1];
      }
  }

  last
}
```

#figure(
  supplement: [Фрагмент кода],
  sourcecode(prefix),
  caption: [Код $pi$-функции]
)

#figure(
  supplement: [Фрагмент кода],
  sourcecode(kmp),
  caption: [Код КМП-алгоритма]
)

=== Тестирование

#figure(
  image(
    "img/test_2-1.png",
    width: 60%
  ),
  caption: [Тест №1]
)

#figure(
  image(
    "img/test_2-2.png",
    width: 60%
  ),
  caption: [Тест №2]
)

#figure(
  image(
    "img/test_2-3.png",
    width: 60%
  ),
  caption: [Тест №3]
)

#figure(
  image(
    "img/test_2-4.png",
    width: 60%
  ),
  caption: [Тест №4]
)

#figure(
  image(
    "img/test_2-5.png",
    width: 60%
  ),
  caption: [Тест №5]
)

#pagebreak()

= Вывод 

#h(1.25cm) В результате практической работы был изучен и реализован алгоритм Кнута-Морриса-Пратта (КМП) для поиска подстроки в строке. Алгоритм использует префикс-функцию для оптимизации сравнения символов, что позволяет сократить количество операций и, таким образом, повысить эффективность поиска. Префикс-функция строит массив значений, где каждое значение отражает длину наибольшего префикса строки, совпадающего с её суффиксом на каждом шаге. Это позволяет избежать повторных сравнений уже проверенных символов.

Применяя префикс-функцию, алгоритм КМП последовательно проверяет символы текста и шаблона, используя данные о префиксах для "перепрыгивания" несоответствий. При каждом найденном совпадении алгоритм фиксирует позицию начала подстроки, а затем продолжает проверку, что позволяет обнаружить все вхождения шаблона в тексте. Полученная временная сложность $O(m + n)$, где $m$ -- длина текста, а $n$ -- длина шаблона, подтверждает эффективность алгоритма по сравнению с наивными методами поиска.